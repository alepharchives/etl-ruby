#!/usr/bin/env ruby

require 'rubygems'
require 'spec'

require File.expand_path("#{File.dirname(__FILE__)}/../../../../")  + '/spec_helper'

include BehaviourSupport
include MIS::Framework

describe given( DecoratorFilter ), 'when initializing a new instance' do

    it 'should explode if the supplied target filter is missing' do
        lambda {
            DecoratorFilter.new( nil )
        }.should raise_error( ArgumentError, "the 'target filter' argument cannot be nil" )
    end
    
    it 'should explode unless supplied with a :filter message handling block' do
        mock_target_filter = mock( 'dummy filter', :mock_object => true )
        lambda {
            DecoratorFilter.new( mock_target_filter )
        }.should raise_error( ArgumentError, "the 'filter block' argument cannot be nil" )
    end
    
    it 'should explode if the supplied :filter handling block has the wrong arity' do
        filter = mock( 'a filter', :mock_object => true )
        block_with_incorrect_arity = lambda { |only_one_argument| }
        lambda {
            DecoratorFilter.new( filter, &block_with_incorrect_arity )
        }.should raise_error( ArgumentError, "the 'filter block' must have an arity of 3" )
    end
    
    it 'should call the supplied block when the filter message is received' do
        target = mock( 'target', :null_object => true )
        target.should_not_receive(:filter)
        input, filter_chain = 'in', mock( 'filter-chain' )
        filter_chain.should_receive( :proceed ).once.with( input )
        proxy = DecoratorFilter.new( target ) do | target_filter, input_data, fc |
            target_filter.should equal( target )
            input_data.should eql( input )
            fc.should equal( filter_chain )
            fc.proceed( input )
        end
        proxy.filter input, filter_chain
    end
    
    it 'should wrap any explosions from the call to the processing block with a filter exception' do
        target, filter_chain = get_target_and_filter_chain
        input = 'input'
        expected_error_message = 'some error message!'
        proxy = DecoratorFilter.new( target ) { |a,b,c| raise StandardError, expected_error_message, caller }
        lambda {
            begin
                proxy.filter( input, filter_chain )
            rescue FilterException => ex
                ex.message.should eql( expected_error_message )
                ex.filter.should equal( proxy )
                ex.input_data.should eql( input )
                ex.cause.should be_an_instance_of( StandardError )
                raise ex
            end
        }.should raise_error( FilterException )
    end
    
    it 'should allow any filter exceptions generated by the processing block, to propagate directly to the caller' do
        target, filter_chain = get_target_and_filter_chain
        input = 'input'
        exception_to_raise = FilterException.new( 'message' )
        proxy = DecoratorFilter.new( target ) { |a,b,c| raise exception_to_raise }
        begin
            proxy.filter( input, filter_chain )
        rescue FilterException => ex
            ex.should eql( exception_to_raise )
        end
    end
    
    def get_target_and_filter_chain
        target, filter_chain = *( [1,2].collect { |var| mock( var, :null_object => true ) } )
        return *[ target, filter_chain ]
    end

end
